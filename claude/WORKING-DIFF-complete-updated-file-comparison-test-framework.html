<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Updated Comprehensive File Comparison Test Framework with Debugging</title>
    <script src="https://unpkg.com/prettier@2.8.8/standalone.js"></script>
    <script src="https://unpkg.com/prettier@2.8.8/parser-babel.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-javascript.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; }
        .code-display, .test-results, .debug-console { margin-top: 20px; }
        .test-case { margin-bottom: 10px; padding: 10px; border: 1px solid #ddd; }
        .pass { background-color: #e6ffe6; }
        .fail { background-color: #ffe6e6; }
        pre[class*="language-"] { margin: 0; overflow-x: auto; }
        .debug-console { 
            height: 300px; 
            overflow-y: auto; 
            border: 1px solid #ccc; 
            padding: 10px; 
            background-color: #f9f9f9; 
        }
        .debug-entry { margin-bottom: 5px; }
        .error { color: red; }
        .info { color: blue; }
    </style>
</head>
<body>
    <h1>Updated Comprehensive File Comparison Test Framework with Debugging</h1>
    <div id="code-display" class="code-display">
        <h2>Function Code:</h2>
        <pre><code id="function-code" class="language-javascript"></code></pre>
        <h2>Test Cases:</h2>
        <pre><code id="test-code" class="language-javascript"></code></pre>
    </div>
    <div id="test-results" class="test-results"></div>
    <h2>Debug Console:</h2>
    <div id="debug-console" class="debug-console"></div>

    <script>
        function debug(message, type = 'info') {
            console.log(message);
            const debugConsole = document.getElementById('debug-console');
            const entry = document.createElement('div');
            entry.className = `debug-entry ${type}`;
            entry.textContent = `${new Date().toISOString()} [${type.toUpperCase()}]: ${message}`;
            debugConsole.appendChild(entry);
            debugConsole.scrollTop = debugConsole.scrollHeight;
        }

        const fileSystem = {
            "src/main.rs": `
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("key1", "value1");
    map.insert("key2", "value2");

    for (key, value) in &map {
        println!("{}: {}", key, value);
    }
}`
        };

        function compareHunksToFiles(searches) {
            debug("Starting compareHunksToFiles function");
            const results = {};

            for (const [fileName, hunks] of Object.entries(searches)) {
                debug(`Processing file: ${fileName}`);
                debug(`File content: ${JSON.stringify(fileSystem[fileName])}`);

                if (!fileSystem.hasOwnProperty(fileName)) {
                    debug(`File not found: ${fileName}`, "error");
                    results[fileName] = {
                        error: `File "${fileName}" not found in the file system.`,
                        hunks: hunks.map((hunk) => ({
                            hunkLines: hunk[0].split("\n").filter((line) => line.trim() !== "").length,
                            matchPercentage: 0,
                        })),
                    };
                    continue;
                }

                const file = fileSystem[fileName].split("\n");
                debug(`Original file lines: ${JSON.stringify(file)}`);
                debug(`Original file line count: ${file.length}`);

                const nonEmptyLines = file.map((line, index) => ({ line: line.trim(), actualLineNum: index + 1 }))
                                          .filter(({ line }) => line !== "");
                debug(`Non-empty file lines: ${JSON.stringify(nonEmptyLines)}`);
                debug(`Non-empty file line count: ${nonEmptyLines.length}`);

                results[fileName] = {
                    fileName,
                    fileLines: file.length,
                    hunks: hunks.map((hunk, hunkIndex) => {
                        debug(`Processing hunk ${hunkIndex + 1} in ${fileName}`);
                        const hunkLines = hunk[0].split("\n").filter((line) => line.trim() !== "");
                        debug(`Processed hunk lines: ${JSON.stringify(hunkLines)}`);

                        const hunkResult = {
                            matches: [],
                            mismatches: [],
                            hunkLines: hunkLines.length,
                            matchPercentage: 0,
                            errors: [],
                        };

                        hunkLines.forEach((hunkLine, hunkLineIndex) => {
                            debug(`Processing hunk line: ${hunkLine}`);
                            const fileIndex = nonEmptyLines.findIndex(({ line }) => line === hunkLine.trim());
                            if (fileIndex !== -1) {
                                debug(`Match found at non-empty file index ${fileIndex}`);
                                hunkResult.matches.push({
                                    hunkLineNum: hunkLineIndex + 1,
                                    fileLineNum: nonEmptyLines[fileIndex].actualLineNum,
                                    content: hunkLine.trim(),
                                });
                            } else {
                                debug(`Mismatch found: ${hunkLine.trim()}`, "error");
                                hunkResult.mismatches.push({
                                    hunkLineNum: hunkLineIndex + 1,
                                    content: hunkLine.trim(),
                                });
                                hunkResult.errors.push(
                                    `Line ${hunkLineIndex + 1} of hunk not found in ${fileName}: "${hunkLine.trim()}"`
                                );
                            }
                        });

                        hunkResult.matchPercentage = (hunkResult.matches.length / hunkLines.length) * 100;
                        debug(`Hunk ${hunkIndex + 1} processed. Match percentage: ${hunkResult.matchPercentage}%`);
                        return hunkResult;
                    }),
                };
            }

            debug("compareHunksToFiles function completed");
            debug(`Final results: ${JSON.stringify(results)}`);
            return results;
        }

        function compareResults(expected, actual) {
            debug("Comparing expected and actual results");
            const differences = [];

            if (expected.fileLines !== actual.fileLines) {
                differences.push(`File line count mismatch. Expected: ${expected.fileLines}, Actual: ${actual.fileLines}`);
            }

            expected.hunks.forEach((expectedHunk, hunkIndex) => {
                const actualHunk = actual.hunks[hunkIndex];
                if (!actualHunk) {
                    differences.push(`Missing hunk ${hunkIndex + 1} in actual results`);
                    return;
                }

                expectedHunk.matches.forEach((expectedMatch, matchIndex) => {
                    const actualMatch = actualHunk.matches[matchIndex];
                    if (!actualMatch) {
                        differences.push(`Missing match ${matchIndex + 1} in hunk ${hunkIndex + 1}`);
                        return;
                    }

                    if (expectedMatch.hunkLineNum !== actualMatch.hunkLineNum) {
                        differences.push(`Hunk line number mismatch in hunk ${hunkIndex + 1}, match ${matchIndex + 1}. Expected: ${expectedMatch.hunkLineNum}, Actual: ${actualMatch.hunkLineNum}`);
                    }

                    if (expectedMatch.fileLineNum !== actualMatch.fileLineNum) {
                        differences.push(`File line number mismatch in hunk ${hunkIndex + 1}, match ${matchIndex + 1}. Expected: ${expectedMatch.fileLineNum}, Actual: ${actualMatch.fileLineNum}`);
                    }

                    if (expectedMatch.content !== actualMatch.content) {
                        differences.push(`Content mismatch in hunk ${hunkIndex + 1}, match ${matchIndex + 1}. Expected: "${expectedMatch.content}", Actual: "${actualMatch.content}"`);
                    }
                });
            });

            return differences;
        }

        const tests = [];
        function describe(description, testFunc) {
            tests.push({ description, testFunc });
        }

        function expect(actual) {
            return {
                toBe: (expected) => {
                    const actualStr = JSON.stringify(actual);
                    const expectedStr = JSON.stringify(expected);
                    if (actualStr === expectedStr) {
                        return { pass: true, message: 'Test passed' };
                    } else {
                        return { pass: false, message: `Expected ${expectedStr}, but got ${actualStr}` };
                    }
                }
            };
        }

        describe("File Comparison Function - Realistic Tests", () => {
            const results = [];

            const rustSearches = {
                "src/main.rs": [
                    [`use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("key1", "value1");`],
                    [`for (key, value) in &map {
        println!("{}: {}", key, value);
    }`]
                ]
            };
            const expectedResult = {
                "src/main.rs": {
                    fileName: "src/main.rs",
                    fileLines: 12,
                    hunks: [
                        {
                            matches: [
                                { hunkLineNum: 1, fileLineNum: 2, content: "use std::collections::HashMap;" },
                                { hunkLineNum: 2, fileLineNum: 4, content: "fn main() {" },
                                { hunkLineNum: 3, fileLineNum: 5, content: "let mut map = HashMap::new();" },
                                { hunkLineNum: 4, fileLineNum: 6, content: 'map.insert("key1", "value1");' }
                            ],
                            mismatches: [],
                            hunkLines: 4,
                            matchPercentage: 100,
                            errors: []
                        },
                        {
                            matches: [
                                { hunkLineNum: 1, fileLineNum: 9, content: "for (key, value) in &map {" },
                                { hunkLineNum: 2, fileLineNum: 10, content: 'println!("{}: {}", key, value);' },
                                { hunkLineNum: 3, fileLineNum: 11, content: "}" }
                            ],
                            mismatches: [],
                            hunkLines: 3,
                            matchPercentage: 100,
                            errors: []
                        }
                    ]
                }
            };
            
            const actualResult = compareHunksToFiles(rustSearches);
            const differences = compareResults(expectedResult["src/main.rs"], actualResult["src/main.rs"]);
            
            if (differences.length === 0) {
                results.push({ pass: true, message: 'Test passed' });
            } else {
                results.push({ pass: false, message: `Test failed. Differences:\n${differences.join('\n')}` });
            }

            const nonExistentFileSearches = {
                "non_existent.rs": [
                    [`This file does not exist`]
                ]
            };
            results.push(expect(compareHunksToFiles(nonExistentFileSearches)).toBe({
                "non_existent.rs": {
                    error: 'File "non_existent.rs" not found in the file system.',
                    hunks: [{ hunkLines: 1, matchPercentage: 0 }]
                }
            }));

            return results;
        });

        function runTests() {
            debug("Starting test execution");
            const resultsContainer = document.getElementById('test-results');
            tests.forEach(test => {
                debug(`Executing test: ${test.description}`);
                const results = test.testFunc();
                const testCase = document.createElement('div');
                testCase.className = 'test-case';
                testCase.innerHTML = `<h3>${test.description}</h3>`;
                
                results.forEach((result, index) => {
                    const resultElement = document.createElement('p');
                    resultElement.textContent = `Test ${index + 1}: ${result.message}`;
                    resultElement.className = result.pass ? 'pass' : 'fail';
                    testCase.appendChild(resultElement);
                    debug(`Test ${index + 1} result: ${result.pass ? 'PASS' : 'FAIL'}`);
                });

                resultsContainer.appendChild(testCase);
            });
            debug("Test execution completed");
        }

        function formatCode(code) {
            try {
                return prettier.format(code, {
                    parser: "babel",
                    plugins: prettierPlugins,
                });
            } catch (error) {
                debug(`Error formatting code: ${error.message}`, 'error');
                return code;
            }
        }

        function displayCode() {
            debug("Displaying code");
            try {
                const functionCode = compareHunksToFiles.toString();
                const testCode = tests[0].testFunc.toString();

                document.getElementById('function-code').textContent = formatCode(functionCode);
                document.getElementById('test-code').textContent = formatCode(testCode);
                Prism.highlightAll();
                debug("Code display completed");
            } catch (error) {
                debug(`Error displaying code: ${error.message}`, 'error');
            }
        }

        window.onload = () => {
            debug("Page loaded, initializing application");
            displayCode();
            runTests();
            debug("Application initialization completed");
        };
    </script>
</body>
</html>
